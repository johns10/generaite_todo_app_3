
# 2024-09-08 13:46:24.901632
+Create a new file src/config.rs that contains all the configurations necessary to run a web server and connect to a database, in this form:

# 2024-09-08 13:46:33.553319
+/run cargo add serde --features derive

# 2024-09-08 13:46:35.477396
+impl AppConfig {

# 2024-09-08 13:48:18.371034
+Create config files for the test/dev/prod environments.

# 2024-09-08 13:48:53.569357
+/run cargo add toml

# 2024-09-08 13:49:03.256954
+/run RUST_ENV=dev cargo run

# 2024-09-08 13:57:57.518842
+/run RUST_ENV=dev cargo run

# 2024-09-08 14:02:34.513119
+/drop *

# 2024-09-08 14:02:36.458832
+Create a new file domain/src/db.rs for creating the database connection
+
+sea_orm::DatabaseConnection;
+
+pub struct Database {
+    pub connection: DatabaseConnection,
+}
+
+impl Database {
+    pub async fn new(database_url: &str) -> Result<Self, sea_orm::DbErr> {
+        let connection = sea_orm::Database::connect(database_url).await?;
+        Ok(Self { connection })
+    }
+}

# 2024-09-08 14:03:07.390366
+/run cargo run --bin domain

# 2024-09-08 14:14:28.549716
+/drop domain/Cargo.toml

# 2024-09-08 14:14:34.181374
+/add src/main.rs

# 2024-09-08 14:14:39.191347
+/add domain/src/repository.rs

# 2024-09-08 14:14:43.841444
+/ls

# 2024-09-08 14:15:07.856293
+This guide will walk you through the process of setting up the database connection and repository in your src/main.rs file, focusing on the SeaORM setup without the Axum-specific parts.
+Step 1: Import Required Dependencies
+First, ensure you have the necessary imports at the top of your src/main.rs file:
+rustCopyuse std::sync::Arc;
+use domain::{db, repository::Repository};
+
+mod config;
+
+use crate::config::Settings;
+Step 2: Set Up the Database Connection
+Inside your main function, add the following code to establish the database connection:
+rustCopy#[tokio::main]
+async fn main() -> anyhow::Result<()> {
+    let settings = Settings::new().expect("Failed to load settings");
+
+    let conn = Arc::new(db::initialize(&settings.database_url).await?);
+    // ... rest of the main function
+}
+This code does the following:
+
+Loads the application settings (including the database URL)
+Initializes the database connection using the db::initialize function
+Wraps the connection in an Arc for safe sharing across threads
+
+Step 3: Create the Repository
+After setting up the connection, create the repository:
+rustCopylet repository = Repository::new(conn);
+This line creates a new Repository instance using the database connection.
+Complete main.rs Example
+Here's how your src/main.rs file should look with just the database and repository setup:
+rustCopyuse std::sync::Arc;
+use domain::{db, repository::Repository};
+
+mod config;
+
+use crate::config::Settings;
+
+#[tokio::main]
+async fn main() -> anyhow::Result<()> {
+    let settings = Settings::new().expect("Failed to load settings");
+
+    let conn = Arc::new(db::initialize(&settings.database_url).await?);
+    let repository = Repository::new(conn);
+
+    // You can now use the `repository` for database operations
+
+    Ok(())
+}
+

# 2024-09-08 14:15:27.908887
+/run cargo run

# 2024-09-08 14:23:07.057405
+/drop *

# 2024-09-08 14:23:09.898586
+Navigate to the web/src directory.
+Create a new file named router.rs.
+Open router.rs in your text editor.
+Add the following content:
+
+rustCopyuse axum::{routing::get_service, Router};
+use tower_cookies::CookieManagerLayer;
+use tower_http::services::ServeDir;
+
+use crate::AppState;
+
+pub fn create_router(state: AppState) -> Router {
+    Router::new()
+        .nest_service(
+            "/static",
+            get_service(ServeDir::new(concat!(
+                env!("CARGO_MANIFEST_DIR"),
+                "/static"
+            )))
+            .handle_error(|error| async move {
+                (
+                    axum::http::StatusCode::INTERNAL_SERVER_ERROR,
+                    format!("Unhandled internal error: {error}"),
+                )
+            }),
+        )
+        .layer(CookieManagerLayer::new())
+        .with_state(state)
+}
+

# 2024-09-08 14:24:02.568963
+/run cargo build

# 2024-09-08 14:26:21.710001
+In the web/src directory, create a new file named server.rs.
+Open server.rs in your text editor.
+Add the following content:
+
+rustCopyuse crate::{router, AppState};
+use axum::Router;
+use domain::repository::Repository;
+use tera::Tera;
+
+pub fn create_app(repository: Repository) -> anyhow::Result<Router> {
+    let templates = Tera::new(concat!(env!("CARGO_MANIFEST_DIR"), "/templates/**/*"))
+        .expect("Tera initialization failed");
+    let state = AppState::new(repository, templates);
+    Ok(router::create_router(state))
+}
+
+pub async fn start(app: Router, host: &str, port: u16) -> anyhow::Result<()> {
+    let server_url = format!("{host}:{port}");
+    let listener = tokio::net::TcpListener::bind(&server_url).await?;
+    axum::serve(listener, app).await?;
+    Ok(())
+}
+

# 2024-09-08 14:27:43.831978
+/run cargo update

# 2024-09-08 14:27:46.886923
+/run cargo build

# 2024-09-08 14:29:29.785073
+In the web/src directory, create a new file named app_state.rs.
+Open app_state.rs in your text editor.
+Add the following content:
+
+rustCopyuse domain::repository::Repository;
+use std::sync::Arc;
+use tera::Tera;
+
+pub struct AppState {
+    pub repository: Arc<Repository>,
+    pub templates: Tera,
+}
+
+impl AppState {
+    pub fn new(repository: Repository, templates: Tera) -> Self {
+        Self {
+            repository: Arc::new(repository),
+            templates,
+        }
+    }
+}
+
+impl Clone for AppState {
+    fn clone(&self) -> Self {
+        Self {
+            repository: Arc::clone(&self.repository),
+            templates: self.templates.clone(),
+        }
+    }
+}
